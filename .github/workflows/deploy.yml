name: ğŸš€ Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      rollback_version:
        description: 'Rollback to specific commit (optional)'
        required: false
        type: string

env:
  DEPLOY_PATH: /opt/docker-containers/ticket-system/Bachelor
  BACKUP_PATH: /opt/backups/ticket-system
  MAX_BACKUPS: 5

jobs:
  # Pre-deployment checks
  pre-deploy:
    runs-on: ubuntu-latest
    environment: production
    outputs:
      deployment_id: ${{ steps.gen-id.outputs.deployment_id }}
      commit_sha: ${{ steps.commit.outputs.sha }}
    steps:
      - name: ğŸ” Generate Deployment ID
        id: gen-id
        run: echo "deployment_id=$(date +%Y%m%d_%H%M%S)_$(echo ${{ github.sha }} | cut -c1-8)" >> $GITHUB_OUTPUT

      - name: ğŸ“‹ Get Commit Info
        id: commit
        run: echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: ğŸ” Pre-deployment Health Check
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "ğŸ” Pre-deployment system check..."
            
            # Check disk space
            if [ $(df / | tail -1 | awk '{print $5}' | sed 's/%//') -gt 85 ]; then
              echo "âŒ Disk space over 85% - aborting deployment"
              exit 1
            fi
            
            # Check if services are currently running
            cd ${{ env.DEPLOY_PATH }}
            if docker compose -f docker-compose.prod.yml ps --services --filter "status=running" | wc -l | grep -q "^0$"; then
              echo "âš ï¸ No services currently running - first deployment"
            else
              echo "âœ… Services currently running"
            fi
            
            echo "âœ… Pre-deployment checks passed"

  # Backup current state
  backup:
    needs: pre-deploy
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: ğŸ’¾ Create Backup
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            DEPLOYMENT_ID="${{ needs.pre-deploy.outputs.deployment_id }}"
            
            echo "ğŸ’¾ Creating backup for deployment: $DEPLOYMENT_ID"
            
            # Create backup directory
            mkdir -p ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID
            
            cd ${{ env.DEPLOY_PATH }}
            
            # Backup database
            echo "ğŸ“Š Backing up database..."
            if docker compose -f docker-compose.prod.yml ps postgres | grep -q "Up"; then
              docker compose -f docker-compose.prod.yml exec -T postgres pg_dump -U ${{ secrets.POSTGRES_USER }} -d ${{ secrets.POSTGRES_DB }} > ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/database.sql
              echo "âœ… Database backup created"
            else
              echo "âš ï¸ Database not running, skipping backup"
            fi
            
            # Backup uploads/data
            echo "ğŸ“ Backing up application data..."
            if [ -d "uploads" ]; then
              cp -r uploads ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/
              echo "âœ… Uploads backed up"
            fi
            
            # Backup current git state
            echo "ğŸ“ Recording current git state..."
            git rev-parse HEAD > ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/git_commit.txt
            git status --porcelain > ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/git_status.txt
            
            # Backup environment files
            echo "âš™ï¸ Backing up configuration..."
            cp .env ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/.env 2>/dev/null || echo "No .env file found"
            cp docker-compose.prod.yml ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/ 2>/dev/null || echo "No docker-compose.prod.yml found"
            
            # Create backup metadata
            cat > ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID/metadata.json << EOF
            {
              "deployment_id": "$DEPLOYMENT_ID",
              "timestamp": "$(date -Iseconds)",
              "commit_sha": "${{ needs.pre-deploy.outputs.commit_sha }}",
              "backup_type": "pre_deployment",
              "github_run_id": "${{ github.run_id }}"
            }
            EOF
            
            echo "âœ… Backup completed: ${{ env.BACKUP_PATH }}/$DEPLOYMENT_ID"
            
            # Cleanup old backups (keep only last 5)
            echo "ğŸ§¹ Cleaning up old backups..."
            cd ${{ env.BACKUP_PATH }}
            ls -t | tail -n +$((${{ env.MAX_BACKUPS }} + 1)) | xargs -r rm -rf
            echo "âœ… Old backups cleaned up"

  # Main deployment
  deploy:
    needs: [pre-deploy, backup]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: ğŸš€ Deploy Application
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            DEPLOYMENT_ID="${{ needs.pre-deploy.outputs.deployment_id }}"
            
            echo "ğŸš€ Starting deployment: $DEPLOYMENT_ID"
            cd ${{ env.DEPLOY_PATH }}
            
            # Handle rollback if specified
            if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
              echo "ğŸ”„ Rolling back to: ${{ github.event.inputs.rollback_version }}"
              git fetch origin
              git reset --hard ${{ github.event.inputs.rollback_version }}
            else
              echo "ğŸ“¥ Fetching latest code..."
              git fetch origin
              git reset --hard origin/main
            fi
            
            # Graceful shutdown with timeout
            echo "ğŸ›‘ Gracefully stopping services..."
            if docker compose -f docker-compose.prod.yml ps --services --filter "status=running" | grep -q .; then
              # Give services time to finish current requests
              docker compose -f docker-compose.prod.yml stop --timeout 60
              docker compose -f docker-compose.prod.yml down --timeout 30
              echo "âœ… Services stopped gracefully"
            else
              echo "â„¹ï¸ No running services to stop"
            fi
            
            # Build and start services
            echo "ğŸ”¨ Building and starting services..."
            docker compose -f docker-compose.prod.yml up -d --build --force-recreate
            
            echo "âœ… Services started"

  # Health checks and verification
  verify:
    needs: [pre-deploy, deploy]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: ğŸ¥ Comprehensive Health Check
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            DEPLOYMENT_ID="${{ needs.pre-deploy.outputs.deployment_id }}"
            
            echo "ğŸ¥ Running comprehensive health checks for: $DEPLOYMENT_ID"
            cd ${{ env.DEPLOY_PATH }}
            
            # Wait for services to fully start
            echo "â³ Waiting for services to initialize..."
            sleep 45
            
            # Check container status
            echo "ğŸ³ Checking container status..."
            RUNNING_CONTAINERS=$(docker compose -f docker-compose.prod.yml ps --services --filter "status=running" | wc -l)
            TOTAL_CONTAINERS=$(docker compose -f docker-compose.prod.yml config --services | wc -l)
            
            echo "Running containers: $RUNNING_CONTAINERS/$TOTAL_CONTAINERS"
            
            if [ "$RUNNING_CONTAINERS" -ne "$TOTAL_CONTAINERS" ]; then
              echo "âŒ Not all containers are running!"
              docker compose -f docker-compose.prod.yml ps
              exit 1
            fi
            
            # Database health check
            echo "ğŸ“Š Checking database connectivity..."
            if ! docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U ${{ secrets.POSTGRES_USER }} -d ${{ secrets.POSTGRES_DB }}; then
              echo "âŒ Database not ready!"
              exit 1
            fi
            echo "âœ… Database is healthy"
            
            # Backend API health check
            echo "ğŸ”§ Checking backend API..."
            MAX_RETRIES=12
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f -s --max-time 10 http://localhost:4000/health > /dev/null 2>&1; then
                echo "âœ… Backend API is healthy"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "âŒ Backend API health check failed after $MAX_RETRIES attempts"
                  docker compose -f docker-compose.prod.yml logs backend
                  exit 1
                fi
                echo "â³ Backend not ready, retrying in 10s... ($RETRY_COUNT/$MAX_RETRIES)"
                sleep 10
              fi
            done
            
            # Frontend accessibility check
            echo "ğŸŒ Checking frontend accessibility..."
            if curl -f -s --max-time 10 https://utilbox.de > /dev/null 2>&1; then
              echo "âœ… Frontend is accessible"
            else
              echo "âš ï¸ Frontend accessibility check inconclusive (might be CDN/cache)"
            fi
            
            # Check logs for errors
            echo "ğŸ“‹ Checking for critical errors in logs..."
            if docker compose -f docker-compose.prod.yml logs --since=5m backend | grep -i "error\|fatal\|exception" | head -5; then
              echo "âš ï¸ Found some errors in logs (review recommended)"
            else
              echo "âœ… No critical errors in recent logs"
            fi
            
            echo "ğŸ‰ Health checks completed successfully!"

  # Cleanup and notifications
  finalize:
    needs: [pre-deploy, backup, deploy, verify]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: ğŸ§¹ Post-deployment Cleanup
        if: needs.verify.result == 'success'
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "ğŸ§¹ Running post-deployment cleanup..."
            
            # Remove unused Docker images
            docker image prune -f
            
            # Remove old build cache
            docker builder prune -f --filter until=24h
            
            echo "âœ… Cleanup completed"

      - name: ğŸ‰ Success Notification
        if: needs.verify.result == 'success'
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "âœ… Deployment ID: ${{ needs.pre-deploy.outputs.deployment_id }}"
          echo "âœ… Commit: ${{ needs.pre-deploy.outputs.commit_sha }}"
          echo "âœ… Frontend: https://utilbox.de"
          echo "âœ… Backend API: https://api.utilbox.de"
          echo "âœ… Backup created: ${{ env.BACKUP_PATH }}/${{ needs.pre-deploy.outputs.deployment_id }}"

      - name: ğŸš¨ Failure Notification & Rollback Info
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "ğŸ“ Manual intervention required"
          echo "ğŸ”„ To rollback, run: gh workflow run deploy.yml -f rollback_version=<previous_commit>"
          echo "ğŸ“Š Check server logs and backup: ${{ env.BACKUP_PATH }}/${{ needs.pre-deploy.outputs.deployment_id }}"
          
          # In a real scenario, you'd want to trigger alerts here
          # - Slack/Discord webhook
          # - Email notification
          # - PagerDuty alert